super_dict = {}

for(curr_dict in list_of_dicts){
foo(super_dict, curr_dict)

}

function foo(super_dict, curr_dict){
for(curr_key in curr_dict.getKeys()){
observed_value = curr_dict.get(curr_key)

# Base case 1 : current value is unobserved at current depth
if(super_dict.containsKey(curr_key) == FALSE){
# add new empty dictionary for current key
super_dict.put(curr_key, {})
}

# Base case 2 : current value is a dictionary
if(type(observed_value) == "DICTIONARY"){
# call this function again recursively
foo(super_dict.get(curr_key), curr_dict.get(curr_key))

# Base case 3 : current value is not a dictionary / is hash-able
} else {

# Store the value as TRUE / boolean to "save space" and avoid storing lists
super_dict.get(curr_key).put(observed_value, TRUE)
}
}
}


# get unique observations with the following
unique_instances = super_dict.get(SOME_KEY).get(OTHER_KEY)(...).getKEYS()


General Algorithm

Let S_D be an empty dictionary, to be the super dictionary
Let L_D be the input list of dictionaries
For each dictionary D in L_D:
foo(S_D, D)


Function foo()

